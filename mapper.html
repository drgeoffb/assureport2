<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Curriculum Mapping Tool</title>
    <style>
        body { 
            font-family: 'Segoe UI', sans-serif; 
            display: flex; 
            background: #f8f9fa; 
            margin: 0; 
            height: 100vh;
            overflow: hidden;
        }

        /* Left Column: Tree Area */
        #tree-container { 
            flex: 1; 
            padding: 20px 30px; 
            height: 100vh; 
            overflow-y: auto; 
            border-right: 1px solid #dee2e6;
        }

        /* Sticky Filter Bar */
        #filter-bar {
            position: sticky;
            top: 0;
            background: #f8f9fa;
            padding: 15px 0;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            z-index: 100;
            border-bottom: 1px solid #eee;
            align-items: center;
        }

        /* Filter Chips (Rectangles) */
        .filter-chip {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        .filter-chip:hover { opacity: 0.8; transform: translateY(-1px); }
        .chip-red { background-color: #dc3545; }
        .chip-green { background-color: #28a745; }
        .chip-level { background-color: #17a2b8; opacity: 0.4; } /* Dim when inactive */
        .chip-level.active { opacity: 1; box-shadow: 0 0 0 2px #000; }
        .chip-gray { background-color: #6c757d; }
        .chip-outline { background-color: transparent; border: 1px solid #6c757d; color: #6c757d; }

        .chip-orange { background-color: #fd7e14; opacity: 0.5; }
        .chip-orange.active { opacity: 1; border: 2px solid #000; }

        .chip-rel { background-color: #f8f9fa; border: 1px solid #ccc; color: #333; }
        .chip-rel.active { background-color: #212529; color: #fff; border-color: #212529; }

        .type-badge { padding: 2px 6px; border-radius: 4px; color: #fff; font-size: 0.7em; }
        .aqf { background: #6f42c1; } /* Purple */
        .clo { background: #007bff; } /* Blue */
        .slo { background: #20c997; } /* Teal */
        .alo { background: #ffc107; color: #000; } /* Yellow */

        /* Color coding for outcome types */
        .text-aqf { color: #6f42c1 !important; font-weight: bold; } /* Purple */
        .text-clo { color: #007bff !important; font-weight: bold; } /* Blue */
        .text-slo { color: #20c997 !important; font-weight: bold; } /* Teal */
        .text-alo { color: #fd7e14 !important; font-weight: bold; } /* Orange */

        /* Small badge style for the prefix */
        .type-indicator {
            font-size: 0.7em;
            text-transform: uppercase;
            padding: 1px 4px;
            border-radius: 3px;
            background: #eee;
            margin-right: 5px;
            border: 1px solid #ccc;
        }

        .pruned { display: none !important; }

        #tree-search {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            flex-grow: 1;
            min-width: 150px;
        }

        /* Tree Structure */
        .node { margin-left: 20px; border-left: 1px solid #dee2e6; }
        .folder {
            display: flex;
            align-items: center;
            background: #e9ecef;
            margin: 4px 0;
            padding: 10px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 4px;
        }
        .folder.collapsed { background-color: #dae0e5; border-left: 4px solid #007bff; }
        
        .outcome {
            display: flex;
            align-items: center;
            background: white;
            border: 1px solid #ddd;
            margin: 2px 0;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .outcome.mapped { border-left: 5px solid #28a745; }
        .outcome.orphan { border-left: 5px solid #dc3545; }
        .outcome:hover { background: #f0f7ff; border-color: #007bff; }

        .status-icon { width: 25px; flex-shrink: 0; }
        .item-name { flex-grow: 1; }
        .tag { font-size: 0.75em; color: #888; margin-left: 10px; }

        /* Right Column: Dock & Console */
        #staging-dock {
            width: 340px;
            height: 100vh;
            background: white;
            display: flex;
            flex-direction: column;
            box-shadow: -4px 0 15px rgba(0,0,0,0.05);
        }
        .dock-header { background: #007bff; color: white; padding: 15px; font-weight: bold; }
        #staged-content { flex: 1; padding: 20px; text-align: center; }
        #log { 
            height: 250px; background: #222; color: #0f0; 
            font-family: monospace; font-size: 0.75em; padding: 10px; 
            overflow-y: auto; border-top: 2px solid #444; 
        }

        .hidden { display: none !important; }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }     
        }   
    </style>
</head>
<body>

    <div id="tree-container">
        <div id="filter-bar">
            <button class="filter-chip chip-red" onclick="applyStatusFilter('orphan')">Gaps</button>
            <button class="filter-chip chip-green" onclick="applyStatusFilter('mapped')">Mapped</button>
            
            <button class="filter-chip chip-level" id="btn-L7" onclick="toggleLevel('7')">L7</button>
            <button class="filter-chip chip-level" id="btn-L8" onclick="toggleLevel('8')">L8</button>
            <button class="filter-chip chip-level" id="btn-L9" onclick="toggleLevel('9')">L9</button>

            <button class="filter-chip chip-orange" id="btn-prune" onclick="togglePrune()">
                Hide <span id="prune-count" style="font-weight:normal; font-size:0.8em; margin-left:5px;"></span>
            </button>

            <button class="filter-chip chip-gray" onclick="toggleAllGlobal(true)">Collapse All</button>
            <button class="filter-chip chip-gray" onclick="toggleAllGlobal(false)">Expand All</button>
            <button class="filter-chip chip-outline" onclick="resetAllFilters()">Reset</button>

            <input type="text" id="tree-search" placeholder="Search..." onkeyup="runAllFilters()">
        </div>
        <div id="relationship-filters" style="margin-top: 10px; border-top: 1px solid #ddd; padding-top: 10px;">
            <span style="font-size: 0.8em; color: #666; margin-right: 10px;">RELATIONSHIPS:</span>
            <button class="filter-chip chip-rel active" id="rel-AQF-CLO" onclick="toggleRel('AQF', 'CLO')">AQF ‚Üî CLO</button>
            <button class="filter-chip chip-rel" id="rel-CLO-SLO" onclick="toggleRel('CLO', 'SLO')">CLO ‚Üî SLO</button>
            <button class="filter-chip chip-rel" id="rel-SLO-ALO" onclick="toggleRel('SLO', 'ALO')">SLO ‚Üî ALO</button>
        </div>
        <div id="tree-root">
            <div id="loading-state" style="padding: 20px; color: #666; display: flex; align-items: center;">
                <div class="spinner"></div>
                <div>
                    <span id="timer-display" style="font-weight: bold; color: #007bff; margin-right: 10px;">0s</span>
                    <span id="loading-text">Initializing connection...</span>
                </div>
            </div>
        </div>
    </div>

    <div id="staging-dock">
        <div class="dock-header">Target Selection</div>
        <div id="staged-content">
            <p style="color: #888;">Select an outcome to stage...</p>
        </div>
        <div id="log">> System Ready...</div>
    </div>

<script>
    const API_BASE = "http://localhost:8000";
    const ROOT_ID = 4;
    let activeLevels = new Set();
    let activeStatus = 'all';
    let isPruneActive = false;
    let activeRel = 'AQF-CLO'; // Default view

    async function init() {
        const loader = document.getElementById('loading-text');
        const log = document.getElementById('log');
        const root = document.getElementById('tree-root');
        
        // Timer setup
        let seconds = 0;
        const startTime = Date.now();
        const timerInterval = setInterval(() => {
            seconds = Math.floor((Date.now() - startTime) / 1000);
            // We'll update a dedicated timer span if it exists, 
            // or just prepend it to the loader text
            const timerEl = document.getElementById('timer-display');
            if (timerEl) timerEl.innerText = `${seconds}s`;
        }, 1000);

        try {
            const response = await fetch(`${API_BASE}/outcomes/${ROOT_ID}/stream`);
            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            while (true) {
                const { value, done } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');
                
                lines.forEach(line => {
                    if (!line.startsWith('data: ')) return;
                    const data = JSON.parse(line.replace('data: ', ''));

                    if (data.status === 'info') {
                        loader.innerText = `[${seconds}s] ${data.msg}`;
                        log.innerHTML += `<br>> [${seconds}s] ${data.msg}`;
                        log.scrollTop = log.scrollHeight;
                    } 
                    
                    if (data.status === 'complete') {
                        clearInterval(timerInterval); // Stop the clock!
                        root.innerHTML = renderNode(data.tree);
                        log.innerHTML += `<br><strong>> Total Load Time: ${seconds} seconds.</strong>`;
                        runAllFilters();
                    }
                    
                    if (data.status === 'error') {
                        clearInterval(timerInterval);
                        throw new Error(data.msg);
                    }
                });
            }
        } catch (err) {
            clearInterval(timerInterval);
            root.innerHTML = `<div style="color:red; padding:20px;">Crawl Failed: ${err.message}</div>`;
        }
    }

    function renderNode(node) {
        if (!node) return '';
        if (node.type === 'outcome') {
                const category = getOutcomeCategory(node.name);
                const typeClass = `text-${category.toLowerCase()}`;
                const statusClass = node.mapped_to && node.mapped_to.length > 0 ? 'mapped' : 'orphan';
                
                // AQF is a target only, others are draggable
                const isAQF = category === 'AQF';
                const draggableAttr = isAQF ? '' : 'draggable="true" ondragstart="startDrag(event)"';

                return `
                    <div class="outcome ${statusClass}" 
                        ${draggableAttr}
                        onclick="stageOutcome(${node.id}, '${node.name.replace(/'/g, "\\'")}')"
                        oncontextmenu="showMenu(event, ${node.id}, '${node.name.replace(/'/g, "\\'")}')"
                        ondragover="event.preventDefault()"
                        ondrop="handleDrop(event, ${node.id}, '${node.name.replace(/'/g, "\\'")}')">
                        <span class="type-indicator ${typeClass}">${category}</span>
                        <span class="item-name ${typeClass}">${node.name}</span>
                        ${node.mapped_to && node.mapped_to.length > 0 ? `<div class="mapping-list">${node.mapped_to.map(m => `<span>‚Üí ${m}</span>`).join('')}</div>` : ''}
                    </div>`;
        }
        if (node.type === 'folder') {
            return `
                <div class="node">
                    <div class="folder" onclick="toggleFolder(this)">
                        <span class="status-icon">${node.is_account ? 'üèõÔ∏è' : 'üìÅ'}</span>
                        <span class="item-name">${node.name}</span>
                        <small style="color:#888; margin-left:10px;">[${node.children.length}]</small>
                    </div>
                    <div class="children">
                        ${node.children.map(c => renderNode(c)).join('')}
                    </div>
                </div>`;
        } else {
            const statusClass = node.is_mapped ? 'mapped' : 'orphan';
            return `
                <div class="outcome ${statusClass}" onclick="stageOutcome(${node.id}, '${node.name.replace(/'/g, "\\'")}')">
                    <span class="status-icon">${node.is_mapped ? '‚úÖ' : 'üî¥'}</span>
                    <span class="item-name">${node.name}</span>
                    <span class="tag">#${node.id}</span>
                </div>`;
        }
    }

    function toggleFolder(folderEl) {
        const outcomes = folderEl.nextElementSibling.querySelectorAll(':scope > .outcome');
        const isCurrentlyCollapsed = folderEl.classList.toggle('collapsed');
        outcomes.forEach(o => o.classList.toggle('hidden', isCurrentlyCollapsed));
    }

    function toggleAllGlobal(shouldCollapse) {
        document.querySelectorAll('.outcome').forEach(o => o.classList.toggle('hidden', shouldCollapse));
        document.querySelectorAll('.folder').forEach(f => f.classList.toggle('collapsed', shouldCollapse));
    }

    function toggleLevel(lvl) {
        const btn = document.getElementById(`btn-L${lvl}`);
        if (activeLevels.has(lvl)) {
            activeLevels.delete(lvl);
            btn.classList.remove('active');
        } else {
            activeLevels.add(lvl);
            btn.classList.add('active');
        }
        // Log the action for debugging
        console.log("Active Levels:", Array.from(activeLevels));
        runAllFilters();
    }

    function applyStatusFilter(status) {
        activeStatus = (activeStatus === status) ? 'all' : status;
        runAllFilters();
    }

    function togglePrune() {
        isPruneActive = !isPruneActive;
        const btn = document.getElementById('btn-prune');
        btn.classList.toggle('active', isPruneActive);
        // Simple toggle: button glows when "Hide" is active
        runAllFilters();
    }

    function runAllFilters() {
        const query = document.getElementById('tree-search').value.toLowerCase();
        const outcomes = document.querySelectorAll('.outcome');
        const [relParent, relChild] = activeRel.split('-');

        outcomes.forEach(o => {
            const nameText = o.querySelector('.item-name').innerText;
            const category = getOutcomeCategory(nameText);
            const isMapped = o.classList.contains('mapped');
            
            // 1. Relationship Filter (Only show types in the active pair)
            const matchesRel = (category === relParent || category === relChild);

            // 2. Level Filter (Only if it matches the digit, or if it's an SLO/ALO which might inherit)
            let matchesLevel = activeLevels.size === 0;
            if (activeLevels.size > 0) {
                activeLevels.forEach(lvl => {
                    const levelRegex = new RegExp(`(aqf|clo|level|l| )\s*${lvl}`, 'i');
                    if (levelRegex.test(nameText)) matchesLevel = true;
                });
            }

            // 3. Status & Search
            const matchesStatus = (activeStatus === 'all') || 
                                (activeStatus === 'mapped' && isMapped) || 
                                (activeStatus === 'orphan' && !isMapped);
            const matchesSearch = nameText.toLowerCase().includes(query);

            // Final Visibility
            o.classList.toggle('hidden', !(matchesRel && matchesLevel && matchesStatus && matchesSearch));
        });

        // Run the 'Hide' logic after filtering outcomes
        if (isPruneActive) {
            pruneFolders(); 
        }
    }

    function resetAllFilters() {
        activeLevels.clear();
        activeStatus = 'all';
        document.querySelectorAll('.chip-level').forEach(b => b.classList.remove('active'));
        document.getElementById('tree-search').value = '';
        runAllFilters();
    }

    function stageOutcome(id, name) {
        document.getElementById('staged-content').innerHTML = `
            <div style="padding:15px; border:2px dashed #007bff; background:#eefbff; border-radius:8px;">
                <strong>${name}</strong><br><small>Ready to map</small>
            </div>`;
        document.getElementById('log').innerHTML += `<br>> Staged: ${id}`;
    }

    function getOutcomeCategory(name) {
        const n = name.toUpperCase();
        if (n.includes('AQF')) return 'AQF';
        if (n.includes('CLO')) return 'CLO';
        if (n.includes('SLO')) return 'SLO';
        if (n.includes('ALO') || n.includes('RUBRIC')) return 'ALO';
        return 'OTHER';
    }

    // Define the valid hierarchy order
    const HIERARCHY_ORDER = ['ALO', 'SLO', 'CLO', 'AQF'];

    function canMap(sourceCat, targetCat) {
        const sourceIdx = HIERARCHY_ORDER.indexOf(sourceCat);
        const targetIdx = HIERARCHY_ORDER.indexOf(targetCat);

        // Rule: Target must be exactly one index higher than Source
        return (targetIdx - sourceIdx === 1);
    }

    function handleDrop(event, targetId, targetName) {
        event.preventDefault();
        if (!stagedOutcomeData) return;

        const targetCategory = getOutcomeCategory(targetName);
        
        if (canMap(stagedOutcomeData.category, targetCategory)) {
            // VALID: Execute the mapping
            executeMapping(stagedOutcomeData.id, targetId, targetName);
            document.getElementById('log').innerHTML += 
                `<br><span style="color:green">‚úÖ Mapped ${stagedOutcomeData.category} to ${targetCategory}</span>`;
        } else {
            // INVALID: Show specific error
            const errorMsg = `Structure Violation: Cannot map ${stagedOutcomeData.category} to ${targetCategory}. ` +
                            `Mapping must follow: ALO ‚Üí SLO ‚Üí CLO ‚Üí AQF.`;
            
            document.getElementById('log').innerHTML += `<br><span style="color:#ff4444">‚ùå ${errorMsg}</span>`;
            alert(errorMsg);
        }
    }

    function stageOutcome(id, name) {
        const category = getOutcomeCategory(name);
        const targetNeeded = HIERARCHY_ORDER[HIERARCHY_ORDER.indexOf(category) + 1];

        stagedOutcomeData = { id, name, category };

        document.getElementById('staged-content').innerHTML = `
            <div class="staged-card">
                <span class="type-badge ${category.toLowerCase()}">${category}</span>
                <strong>${name}</strong>
                <div style="margin-top:8px; font-size:0.85em; color:#555;">
                    üëâ Must map to a <strong>${targetNeeded || 'TOP LEVEL'}</strong>
                </div>
            </div>`;
    }
 
    function toggleRel(p, c) {
        activeRel = `${p}-${c}`;
        // Update UI state
        document.querySelectorAll('.chip-rel').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`rel-${activeRel}`).classList.add('active');
        runAllFilters();
    }

    init();
</script>
</body>
</html>